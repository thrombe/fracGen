plan:
  . explain how generation works in comments
  . implement anti-aliasingbin mandlebrot and plotEq
    . try limiting it to selective area (like where there is more detail)
    . is it possible for chaos equations or buddhabrot?
      . no ig. cuz the points are already rounded to pixels
  . 

try:
  . buddhabrot but include the points that dont cross 2. ie dont ignore points inside mandlebrot set
    . or only the points that dont cross 2
  . superimpose mandlebrot on top of few already made buddhabrot images but in different color
  . convolutions on fractals/random images
  . smart long gaussian? blur like the computerphile video
  . the logistic curve or something (veritassium video)
  . lorenz attractor and ++ +3d?
  . chaos equations from code parade
  . the complex cellular automata from sabestian lague
  . 

mandlebrot:
  .

findsol:
  . it seems like there is no easy solution to the two precision problems below.
    . cuz it would need more digits in functions like sin, cos, log etc that are used in s()
    . so first, more digits in sub functions are needed
    . then more digits in calculations of s()
    . and more digits in value of y
  . precision
    . seems like 10^-16 is the max precision (for value of s) :( 
      (it dosent mean solution has this many digits of accuracy :( its a few digits less (10 ish decimal places))
    . the problem happens cuz (i think) dy gets too small to chnage the y value. (too precise compared to y)
    . the problem will get worse as the solution y coord gets higher (ie gain more digits to the left)
    . this should be fixable by bringing the solution down to the x axis
      so if we want more digits, maybe change equation in such a way that the current known sol lies on x axis
    . tho this still wont fix the prob for too long. but maybe can gain a few digits of precision
    . 
  . precision 2.0
    . misses solutions if value of 'accuracy' is less than 10^-14
    . it might still miss some. idk what value of that to choose, so that 
      it dosent miss any values
    . 
  . try to figure out how many digits are good. ie find the error in calculations
  . get a function to calculate intersection of 2 curves
    . this works for only y = f(x) type functions
      /. can do this by f1(x, y)-f2(x, y) and then flip x and y
      /. subtracting values of functions brings down the solution to y == 0
        and flipping x and y gets them on y axis instead.
        so all that needs to be done after that is call findsol(0, ...)
    . 
  . 
