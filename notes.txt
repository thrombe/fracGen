plan:
  . explain how generation works in comments
  \. try limiting anti-aliasing to selective area (like where there is more detail)
    \. how?
  . time estimators instead of percentage (wherever applicable)
  . 

try:
  . buddhabrot but include the points that dont cross 2. ie dont ignore points inside mandlebrot set
    . or only the points that dont cross 2
  . convolutions on fractals/random images
    . convolutions for anti-aliasing (bias)
  . superimpose mandlebrot on top of few already made buddhabrot images but in different color
  . smart long gaussian? blur like the computerphile video
  . the logistic curve or something (veritassium video)
  . lorenz attractor and ++ +3d?
  . chaos equations from code parade
  . the complex cellular automata from sabestian lague
  . 

rust stuff:
  . use command line arguments for ease
  . 

rust buddhabrot:
  . micro-optimisations
  . make board smaller (perhaps u16 or something)
  . make it easier to change parameters. i.e. bring the playable parameters atbone place
  . figure out which rng is better for this
  . 

rust mandlebrot:
  . use a seperate board for each thread and dont use communal memory to distribute
    work, instead just split work evenly by numbers. this makes program use 100% of cpu (all 8 cores)
    . board can be (u8, u8, u8) and also dosent need to be full board, just the portion assigned to
      the thread
  . use the rng that is used in buddhabrot (exclusive range)
  . implement a progress thing somehow in the multi-threaded version
  . try rust mandlebrot in some pc or Google colab (is it really uses all cores)
  . shit x loop outside the threads, to see how slow it gets.
  . try threadpool and stuff (rayon ?)
    . the current methods already provides very close to 4 times performance in 4 cores tho

findsol:
  . try to figure out how many digits are good. ie find the error in calculations
  . get a function to calculate intersection of 2 curves
    . this works for only y = f(x) type functions
      /. can do this by f1(x, y)-f2(x, y) and then flip x and y
      /. subtracting values of functions brings down the solution to y == 0
        and flipping x and y gets them on y axis instead.
        so all that needs to be done after that is call findsol(0, ...)
    . 
  . it seems like there is no easy solution to the two precision problems below.
    . cuz it would need more digits in functions like sin, cos, log etc that are used in s()
    . so first, more digits in sub functions are needed
    . then more digits in calculations of s()
    . and more digits in value of y
  . precision
    . seems like 10^-16 is the max precision (for value of s) :( 
      (it dosent mean solution has this many digits of accuracy :( its a few digits less (10 ish decimal places))
    . the problem happens cuz (i think) dy gets too small to chnage the y value. (too precise compared to y)
    . the problem will get worse as the solution y coord gets higher (ie gain more digits to the left)
    . this should be fixable by bringing the solution down to the x axis
      so if we want more digits, maybe change equation in such a way that the current known sol lies on x axis
    . tho this still wont fix the prob for too long. but maybe can gain a few digits of precision
    . 
  . precision 2.0
    . misses solutions if value of 'accuracy' is less than 10^-14
    . it might still miss some. idk what value of that to choose, so that 
      it dosent miss any values
    . 
  . 
